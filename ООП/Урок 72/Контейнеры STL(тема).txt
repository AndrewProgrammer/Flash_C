Контейнеры: Ассоциативные,адаптерные, псевдо,последовтаельные
Асоциативные: <Binary_Tree><set> - позволяет хранить уникальные значения.
Адаптеры: <stack>, <queue>, <priority_queue>.
Псевдо: <string>
Класс <memory>
shared_prt; - создает множество ссылок, то есть много создателей.
unique_ptr; - такой указатель не может копироватся и владелец только один
//Класс алгоритмов
<algorithm> :
//1)all_of - проверяет условие которое приходит и применяется ко всем методам.
vector<int> v;
all_of(v.begin(), v.end(), isZero)//3)//унарный предикат принимает параметр и возращается bool)
bool IsZero(int x) {return x == 0;}
//2) any_of - проверяет условие которое приходит и применяется ко всем методам и возвращает true
//3) none_of - применяется ко всем методам и проверяет на условие не совпдаает с ним
//4)find(v.begin(), v.end(), 3); // Обходит какой то диапозон и находит нам правильный итератор.
//5)find_if(v.begin(),v.end() ,IsEmpty() ) - передается унарный предикат и проверяет уже по условию и возвращает нам найденный итератор.
bool isEmpty(String s)
{
	return s.IsEmpty();
}
//6) find_if_not - находит итератор который бы не удовлетворял условию нашему,возвращает нам идентификатор который не удолетворяет условию
//7)count(v.begin(),v.end(), 7); //Считает количество 7 в диапозоне, возвращает количевство 7.
//8)count_if(v.begin(),v.end(),IsZero); //Возвращает количество элементов отвечающий этому условию и выводит нам на экран количество этих элементов(идентификаторов).
//9)transform(v1.begin(),v1.end(),v2.begin(),F); //преобразует один тип колекции в другой тип колекции, у нас есть колекция значений но мы хотим создать объекты Gem,трансформация происходит по условию чтоб диапозон значений первого равнялся 2, либо у 2 было одинаково с первым или больше чем первый.
vector<int> v1;
vector<Gem*> v2;
Gem*F(int x)
{
	return new Gem(x);
}
//10)transform(x1.begin(),x1.end(),x2.begin(),result.begin(),sum); - 3 - описывают диапозон первого и второго итераторов(может быть больше у 2 но не меньше чем у первого),4 - итератор на начало результирующий колекции,запсывают куда нам надо, 5 - что мы делаем с этим);
vector<int> x1;
vector<int> x2;
vector<int> result;
int Sum(int a, int b)
{
return a+b;
}
//11)replate(v.begin(),v.end(),3,7); - //Алгоритм для замены значений итераторов по тиапозону,3 - наше старое значение которое мы хотим заменить, 4 - новое значение на которое заменится
//12)replace_if(v.begin(),v.end(),F,7); - //Такой же алгоритм как и выше только с условием(условие пишем как функцию).
//13)auto end = remove(v.begin(),v.end(),4); - //Значение которое нужно удалить, возвращает итератор на новый объект колекции. -  у нас было 124242374  - стало 12237444. ДЛЯ ТОГО ЧТОБЫ УДАЛИТЬ НАШИ 4 нужно: - 
-//14) v.erase(end,v.end());
ну а для того чтобы удалить полностью можно писать так:15) v.erase(remove(v.begin(),v.end(),4),v.end());
//16)v.remove_if(v.begin(),v.end(),Dved) - с условием и передаем туда условие наше в виде функции. 
----------------------
Лямбда Выражений
cout << count_if(v.begin(),v.end(),[](int x){return x < 0;}(Либо d));
auto d = [](int x) -> bool//Лямда,оператор перегрузки [], функция(int x)  и в нем тело return  x < 0;, если не указать bool то оно само вычисляется по телу функции, можно писать без () - так как можно нечего не передавать. [] и {} - ОЧЕНЬ ВАЖНЫЕ ВЕЩИ, НЕЛЬЗЯ УБИРАТЬ
	{
		return x < 0;
	}
d(7);
Если используем Лямбду то пишем тип данных auto.
------------------------------------------------
void F()
{
	vector<int> v;
	v.push_back(10);
	v.push_back(-2);
	v.push_back(3);
	v.push_back(-7);
	this->m_value = 3;
	int y = 0;
	cin >> y;
	string s;
	count_if(v.begin(),v.end(),[](int x) {return x + 5 < 0;});
	count_if(v.begin(),v.end(),[=](int x) {return x + y < 0;});//(=)Конструктор копирования = дает возможность понять компилятору что все значения которые находятся в теле будут взяты из верхней функции.
	count_if(v.begin(),v.end(),[&](int x) {return x + y < 0;});//(&)Будет доступно абсолютно все то что в локальной области видимости полного нашего класса.
	count_if(v.begin(),v.end(),[y](int x) {return x + y < 0;});//только y замкнется
	count_if(v.begin(),v.end(),[y&](int x) {return x + y < 0;});//y& по ссылке
	count_if(v.begin(),v.end(),[&,&y](int x) {return x + y < 0;}); - это ошибка
	count_if(v.begin(),v.end(),[=,y&](int x) {return x + y < 0;}); - мы хотим использовать и по ссылке и по значению
	Если мы пишем поле класса например m_value и хотим использовать с лямбдой то будет:
	count_if(v.begin(),v.end(),[this](int x) {return x + m_value < 0;}); - мы сработались с объектом
}