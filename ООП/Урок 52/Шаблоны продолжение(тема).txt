Когда мы объявляем шаблон мы можем указывать шаблонный тип по умолчанию, например:
template <typename T = int>//Относится к классу
class Foo
{
	Foo <float> a;
	Foo<>b;//будет инт так как мы указали шаблонный тип по умолчанию
};
Пример улучшенный:
template <typename T, typename U = int>//Относится к классу
class Foo
{
	Foo <float> a;
	//Foo<float,char>a;( T будет флоает, а U будет char)
	Foo<bool>b;//Он берет первый T а U будет int
};
Пример ошибки:
template <typename T = int, typename U>//Относится к классу
class Foo
{
	Foo<bool>b;//Ошибка компиляции
};
ОШИБКА:template <typename T = int, typename U>
Ограничения:
1) Параметры по умолчанию передаются всегда слева, например(typename T, typename U = int(Парметр по умолчанию))
---------------------------------------------------------------------------------------------------------------
Интегральные типы данных - все целочисленные и bool, и того 11 типов, используються для классов (плюс unsigned)
В шаблонных типах:
template <int(тип данных) T(Константа)>//Константа на этапе компиляции
class Bar
{
	int ar[T];
}
void main()
{
	Bar <6(Сюда передаем значению)> b;//Константна на этапе компиляции(Применяется например как размер массива)
	Bar <7> b2;
	b = b2;
} 
----------------------------------------------------------------------------------------------------------------
template < typename T(любой тип данных), int SIZE(Константа)(В любом порядке)>
class Bar
{
	T ar[SIZE];
};
void main()
{
	Bar<int , 10> b;
}
---------------------------------------------------------------------------------------------------------------
Полная и частичная спеациализация шаблонов:
1)Полная:
//Много классов
template <typename T,typename U>
class Foo
{
	
};
template <>
class Foo<int>//Полная специализация.Весь список шаблонных типов мы явно указываем
{
	//Разные алгоритмы
}
template <>
class Foo<int,char>//Полная специализация.Весь список шаблонных типов мы явно указываем
{
	//Разные алгоритмы
}
2)Частичная:
//Частичная реализация классов
template <typenmae X>//Частичный,когда не указываем один из параметров
class Foo< int , X>//В любом порядке
{
	
};
template <typenmae X>//Частичный,когда не указываем один из параметров
class Foo< X, int>//В любом порядке
{
	
};
-------------------------------------------------------------------------------------------------------------------
static const bool f = true;//Если  статическое поле является константной и интегрального типа данных то можно прямо в методе класс на писать f = true.
-------------------------------------------------------------------------------------------------------------------
template<typename T>
class Foo
{
	//Из кода шаблона обратиться к шаблонному типу
	typename T::X(В X записывается тип данных T)//Есть T а внутри него X(думает что это статическое поле X), мы хотим создать тип данных X который идет от T(Создаем экземпляр вложенного типа)
	typename T::X(Тип данных указателя)* ptr;//Есть TY
	void F(int a)
	{
		T::X *(умножение) a;//Статическое поле в паблике
	}
	T::X(Это данные,если мы добавляем typename то это тип данных)
};
class Bar
{
public:
	typedef int x;
	class X
	{
	};
};
void main()
{
	Bar::X * ptr;
}
--------------------------------------------------------------------------------------------------------------------