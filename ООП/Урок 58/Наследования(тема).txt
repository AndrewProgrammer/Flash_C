Вложенный клас - это класс описанный внутри другого класса.
class Foo
{
private:
	class Bar//Видет все поля класса и методы класса Foo
	{
		void F(Foo f)
	};
};
void main()
{
	Если бы public: Foo::Bar x;
}
------------------------------------------------------------------ -
Агрегация - описывают одну ситуацию(когда полем одного класса является другой класс(внутри одного объекта мы можем иметь объект другого класса)), подразумевает связь используют.(use)Класс может существовать сам по себе
Композиция - описывают одну ситуацию(когда полем одного класса является другой класс(внутри одного объекта мы можем иметь объект другого класса), подразумевает связь содержит(владеет).(own)Класс не может существовать сам по себе.
Например:
Внешний класс используют другой класс.
Если наш класс использует только часть другого класса.
Есть класс кампания, класс человек, класс учетная запись.
Класс кампания содержит набор людей, но также класс человек может существовать отдельно сам по себе.
А вот класс учетная запись не может существовать отдельно(сам по себе), он нужен другому класса для правильного взаимодействия.
Агрегация либо композиция присутствуют хотя бы одна в любой программе.
--------------------------------------------------------------------------
Наследование(Inharitance) - механизм любого ООП языка, которая позволяет создать один класс на основании другого, получив(при этом всю его функциональность и добавить свою при необходимости).
Решает проблему повторного использавания кода.!!!!--------------------------
Никогда не ставьте в классе Base то что нужно только в некоторых дочерних классов.
Два класса которые учавствуют в наследовательности - Тот класс от которого наследуються она Базовы, Родительский(Base), тот класс который наследует другой класс это Devived(Дочерний).
Множественное наследование - означает что класс наследуется сразу от нескольких родительских классов.Например один дочерний и у него Base классов два и больше.
Родительский класс нечего не знает о дочерних, а дочерний класс знает что у него есть класс Base.
Многоуровневое наследование - это наследования при котором есть Base класс от него дочерний класс, а от дочернего другой дочерний и тогдалее.Например: A(Base) <-B(Devived) <-C(Devived).
Синтаксис наследование :
class Base//Нечем не отличается от простого(Либо #include, либо класс выше)
{
public:
	void F();
};
class Derived : public(сдесь можно нечего не писать - тогда будет private) Base//Дочерний класс.Размер этого класса: Размер класса Base + размер класса дочернего (самого Derived).
{

};
void Main()
{
	Derived d;
	d.F();//Объект класса Derived принимает функциональность метода класса F();
}
Обращение дочернего к private - ошибка
--------------------------------------------------------
Спецификатор доступа protected - снаружи класса выглядет как private, доступен только для дочерних.//Используйте не как поля класса private
Обращение дочернего к protected Base - то можно обратиться.Но protected Base нельзя получить доступ из класса Base.
99 % используем спецификатор доступа public в дочерних классах.
---------------------------------------------------------
Переопределение методов : определение метода с полностью одинаковой сигнатурой, но разной функциональностью(реализацией). 
class Base//Нечем не отличается от простого(Либо #include, либо класс выше)
{
	int a;
public:
	void F();//Метод 1
};
class Derived : public(сдесь можно нечего не писать - тогда будет private) Base//Дочерний класс.Размер этого класса: Размер класса Base + размер класса дочернего (самого Derived).
{
	int b;
	void F();//Переопределение методов ПРИМЕР!!! Метод 2(Он главный теперь)
};
void Main()
{
	Derived d;
	d.F();//Объект класса Derived принимает функциональность метода класса F(); // тут будет void F() в Derived
	Base b;
	b.F()//Разные результаты по сравнению с прошлым d.F();РАБОТАЕТ!!
}
--------------------------------------------------------------
Замещение методов : перегрузка метода из дочернего класса, при этом теряется возможность вызывать перегрузки этого метода(замещенные) из родительского класса, через интерфейс производного.(Тоесть теперь разные сигнатуры, и разные функциональности)
class Base//Нечем не отличается от простого(Либо #include, либо класс выше)
{
	int a;
public:
	void F();//Метод 1
};
class Derived : public(сдесь можно нечего не писать - тогда будет private) Base//Дочерний класс.Размер этого класса: Размер класса Base + размер класса дочернего (самого Derived).
{
	int b;
	void F(int a);//Переопределение методов ПРИМЕР!!! Разные штуки
};
void Main()
{
	Derived d;
	d.F();//Ошибка 
	d.F(3)//Теперь писать так.
	Base b;
	b.F()//Разные результаты по сравнению с прошлым d.F();РАБОТАЕТ!!!
}
-------------------------------------------------------------------
Конструкция которая позволяет использовать только метод класса Base.
class Base//Нечем не отличается от простого(Либо #include, либо класс выше)
{
	int a;
public:
	void F();//Метод 1
	void F(double a);
};
class Derived : public(сдесь можно нечего не писать - тогда будет private) Base//Дочерний класс.Размер этого класса: Размер класса Base + размер класса дочернего (самого Derived).
{
	int b;
	void F(){Base::F();}
	void F(int a){};//Переопределение методов ПРИМЕР!!! Разные штуки
};
void Main()
{
	Derived d;
	d.F();//Будет метод Base
	d.F(3.8)//Будет метод Derived только с типом данных инт.
	Base b;
	b.F(3.8)//Работает метод Base
}
---------------------------------------------------------------------
class Base//Нечем не отличается от простого(Либо #include, либо класс выше)
{
	int a;
public:
	void F();//Метод 1
	void F(double a);
	void F(int a);
};
class Derived : public(сдесь можно нечего не писать - тогда будет private) Base//Дочерний класс.Размер этого класса: Размер класса Base + размер класса дочернего (самого Derived).
{
	using A::F;//РЕШЕНИЕ!!!!Используется когда нужно передать из главного родителя все методы с одинаковым именем но разной сигнатурой
	void F(double,char);
};
void Main()
{
	Derived d;
	d.F();//Тут проблема
}
-------------------------------------------------------------------------------------
Если этот метод является классом Base.(is a - насследование) То выглядит примерно так:Велосипед это транспортное средство.
является(агрегация, композиция).
------------------------------------------------------------------------
Для инкапсуляции важно как класс выглядет снаружи.
Как с точки зрения инкапсуляции спецификаторы доступа private и protected отличаются: НИЧЕМ так как они оба закрывают класс.
---------------------------------------------------------------------------
Вызов конструкторов идет от самого дочернего до родительское, а дальше от тела конструктора родительского до тела конструктора дочернего.
С дестркуторами наоборот.