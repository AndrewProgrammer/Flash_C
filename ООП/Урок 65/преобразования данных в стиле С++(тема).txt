----------------------------------
Преобразования на С: (тип данных)(выражения)
Преобразавания на С++(ВСЕ ЯВНЫЕ)(Все на этапе компиляции, кроме dynamic_cast): 
1) const _cast <type//К какому типу данных мы хотим преобразавать>(expresion)//Предназначен для того чтобы снять модификатор
Например:
const int*p;
int * p2 = const_cast<int*>(p);//Используется для того чтобы менять спецификатор const or valatile(чаще всего меняет переменную с константы к простому типу данных)
2)dynamic_cast(Работает на этапе выполнения, и в пределе одного дерева классов) - 1)необходим для полиморфных преобразований 2)Проверить какой тип там?
Например:
A* a = new A;//Базовый класс
B* b = new B;//Дочерний класс
a = b;
A* x = new B;
B* y = dynamic_cast<B*>(x);//Если будет другой тип данных то вернет nullptr.
3)static_cast//чаще всего используем это - все допустимые преобразования 
4)reinterpret_cast - предназначен для преобразования одних типов данных в кардинально другие типы данных.
Например:
int a;
cin >> a;
int * p = reinterpret_cast<int* a>(a);
-------------------------------------------
Пример:
class Foo
{
	int a;
	int b;
public:
	int* operator &()
	{
		return &b;
	}
};
void main()
{
	Foo f;
	auto(нужен для того чтобы самостоятельно вычислить тип данных, от того что мы пишем справа) p = &f;//int *
	//Решение
	Foo * p = reinterpret_cast<Foo*>(&reinterpret_cast<char&>(f));//char начинается с самого начала
}
template <typename T>//Решение усовершенственное
T* AddressOf(T& obj)
{
	return  reinterpret_cast<T*>(&reinterpret_cast<char&(Если не будет сдесь & то мы будем работать уже с другим объектом(либо с копией другого объекта))>(obj));
}