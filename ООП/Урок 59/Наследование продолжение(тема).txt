Множественное наследование.
Синтаксис:
class Derived : public Base1,public(если будет пусто то private) Base2
{
};
Конструктор копирования:
Derived():Base1(),Base2()...
--------------------------------
Полезность, мы хотим расширить класс испльзуя дополнительные родительские классы.
Их обычно называют Mixin.
Проблемы при множественном наследовании:
1) Ромбовидное наследование(Два дочерних имеют одного родителя)
class B : public A//Проблема 
class C : public A//Проблема
class D : public B , public C//Проблема ABACD
Решение этой проблемы: 
class B : public virtual A//Решение 
class C : public virtual A//Решение
class D : public B , public C//Стало ABCD
2) Проблема конструкторов:
A();//будет работать A(), так как используем virtual(а virtual подразумевает конструктор по умолчанию)
A(int );
B() : A(3)
{
}

A();
A(int );
D() : A(3), B()//Для того чтоб работалы другие конструкторы не по умолчанию, так как мы должны писать с начального класса.
------------------------------------------------------------------
A();
B(int);
B();
B(int a , int b) : A(a)
D(int a , int b) : A(a), B(3,b)
D(5,5);
------------------------------------------------------------------------
C++11 
class Foo (final) - модификатор, закрытый класс от которого нельзя наследоватся(бесплодный).Убивает расширяемость.Если вы хотите чтобы использовали расширяемость то не используйте final.
{
};
-----------------------------------------------------------------------------
Шаблоны могут наследоваться, Например:
template <typename T>
class Base
{
	T x;//int
};
template <typename T>
class Derived : public Base<T>, public A
{
};
Если мы создаем Derived типа данных int
-------------------------------------------------------------------------------
template <typename T>
class Base
{
	T x;//int
};
class Derived : public Base<(указать тип данных обязательно!)(Например-) int>, public A
{
};
-------------------------------------------------------------------------------------------
class A//Класс фигура
{
protected://обращаются только наследники
	A();
	A(int);
	A(Stirng);
};
//class B : public A
//{
	//Конструткор по умолчанию, конструктор переноса, деструктор, конструктор копирования (Есть в нем пустом)
//};
class B : public A
{
	до С++ 11
	B() : A()
	{
	}
	B(int x) : A(x)
	{
	}
	B(String x) : A(x)
	{
	}
	После С++ 11
	using A(название метода(в нашем случаи конструктора))::A(класс А)
};
-------------------------------------------------------------------------------------------------