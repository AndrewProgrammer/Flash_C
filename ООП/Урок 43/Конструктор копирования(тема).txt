class Human
{
private:
	char * m_name;
public:
	Human(const char * name)
	{
		m_name = new char[strlen(name) + 1];
		strcpy(m_name,name);
	}
	Human(const Human& source)// Конструктор копирование
	{
		m_name = new char[strlen(source.m_name)+1];
		strcpy(m_name,source.m_name);
	}
	~Human()
	{
		delete [] m_name;
	}	
	void Human G()
	{
		Human h3;
		return h3;
	}
};
void main()
{
	Human h1("John");// занимает 4 байта как указатель (выделяется 5 ячеек  1 ячейка - 4 байта)
	Human h2 = h1;//копируется поля класса объекта h1,происходит побитовое копирование
	Human h4 = G();
}
Побитовое копирование - это копирование значения каждого поля объекта в сооствествующие поле другого объекта.
Конструктор копирование - нужен для того чтобы описать процесс создания одного объекта на основании другого(копирует один в другой).
Конструктор копирования нам нужен(вызывается не явно):
1)когда мы передаем объект класса в функцию по значению.
2)когда возвращается из функции объект класса ( по значению).
3)когда объект создается как копия другого объекта.
Human* h = new Human;
h->Show();//сразу передаем объект 
(*h).Show();//сначала применяем операцию разыменования и потом уже образаемся к Show()
h2 = h1; - оператор присваивание ( не работает)
Human h2 = h1; - побитовое копирование объекта
В любом Классе есть конструктор копирования.
Если программист явно не написал конструктор копирования то компилятор сам это создаст:
Human (const Human & source)
{
	m_name = source.m_name;
}
либо:
Human(const Human & source) : m_name(source.m_name){}
Правило трех:
1)Если у вас в классе есть один из трех следующих методов (конструктор копирования,оператор присваивания или деструктор), то вы должны скорее всего реализовать оставшееся два.
Сигнатура конструктора - должна состоять из одного параметра типа одного класса для кого пишем этот конструктор копирования, константы и обязательно &(без оперсанда будет бесконечная рекусрия)