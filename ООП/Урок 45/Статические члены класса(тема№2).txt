—татические пол€ - это поле к которому можно обратитс€ не создава€ объект класса.
—татические методы - это метод который можно вызвать не создава€ объект класса.
—татические пол€ - общие дл€ всех объектов класса,если одни объект изменит его то все объекты имеют доступ.
—татическое поле существует даже если не создано не одного объекта класса.
—татические пол€ нужно проинициализировать до вызова main;
  статическим членном класса можно обращатс€ из нестатических методов.
:: - оператор разрешени€ области видимости.
void main()
{
Human::Static(); - обращение к статическому методу.
String s = String::Empty();
}

static - модификатор.
ѕо умолчанию все не статическое.
ќграничени€:
1) в статическом методе нельз€ использовать нестатические пол€ класса и вызывать нестатические методы.
2) в статические методы не передаетс€ this.
class Foo
{
private:
	static int count;
public:
	Foo()
	{
		++count;
	}
static  int GetCount()
	{
		return count;
	}
};
int Foo::count = 0;//пишетс€ в cpp файле класса над реализацией методов класса. 
void main()
{
	Foo f1;
	Foo f2;
	Foo* f3 = new Foo();
	Foo::GetCount();
}
//Problem
Static Initialization Order Fiasco - очень сложна€ ошибка.ѕор€док инициализации статических членов класса не определен.(в разных единицах трансл€ции(в разных cpp файлах)).

A.h;				B.h
class A				class B
{				{
static int A;			static int y;
};				};
A.cpp				B.cpp
int A::x = 10;//ѕроблема	#include "A.h"
				int A B::y = A::x + 10;//ѕроблема
//50% шанс правильной компил€ции
—татическа€ переменна€(static int  X(){static int x = 10;return x;}//метод будет посто€нно инициализироватьс€ быстрее static int y; - это переменна€ котора€ обладает областью видимости локальной и временем жизни глобальной, они инициализируетс€ только один раз при следующем попадении в метод класса это строка со static просо пропускаетс€
–ешение этой проблемы:1)
A.h;								  B.h
class A					    			  class B
{								  {
static int  X()//метод будет посто€нно инициализироватьс€ быстрее static int y;
	{				 			  };
		static int x = 10;
		return x;
	}
};
A.cpp								  B.cpp
int A::x = 10;							  #include "A.h"
								  int A B::y = A::X() + 10;
2)
A.h;								  B.h
class A					    			  class B
{								  {
									static int  X()//метод будет посто€нно инициализироватьс€ быстрее static int y;
								  	{
										static int x = 10;
										return x; 
									}
};
								  };
A.cpp								  B.cpp
int A::x = 10;							  #include "A.h"
								  int A B::y = A::X() + 10;
