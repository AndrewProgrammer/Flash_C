НЕ ИСПОЛЬЗУЙТЕ НИКОГДА ВИРТУАЛЬНЫЕ МЕТОДЫ В КОНСТРУКТОРАХ!!!.
Когда мы создаем иерархию классов, то мы получаем возможность(Можно в указатель базового класса типа А, записать адрес производного класса.)
Полморфизм - это один интерфейс множество реализаций.
Нужен для того чтобы работать  с разными классами как один.
Например:
A(ТИП УКАЗАТЕЛЯ)* ptr = new B;//Мы записали указатель базового класса на класс дочерний B
B* ptr1 = new B;
A* ptr = ptr;
Мы можем так делать так как дочерние классы хранят базовый класс(хоть и этого не видно в коде).
Возможности благодаря таких указателей:
1)
class A
{
public:
	void F();
};
class B : public A
{
public:
	void X();
};
void main()
{ 
	A* ar[3];
	ar[0] = new B();
	ar[1] = new B();
	ar[2] = new A();
	for(int i =0; i < 3; i++)
	{
		ar[i] = F();
	}
}
------------------------------------------------------------------------------------
Класс без полиморфизма:
class Rectangle
{
	int m_width;
	int m_height;
public:
	void SetHeight(int h)
	{
		m_height = h;
	}
	void SetWidht(int w) 
	{
		m_width = w;
	}
};
class Square : public Rectangle
{
public:
//Проблема(не каждый прямоугольник квадрат)
	void SetHeight(int h)//РЕШЕНИЕ!
	{				//РЕШЕНИЕ!
		Rectangle::SetHeight(h);//РЕШЕНИЕ!
		Rectangle::SetWidth(w);//РЕШЕНИЕ!
	}				//РЕШЕНИЕ!
};
void main()
{
	Square s;
	s.SetHeight(6);
}
-------------------------------------------------------------------------------------
Класс с полиморфизмом.
class Rectangle
{
	int m_width;
	int m_height;
public:
virtual void SetHeight(int h)//(Позднее связывание, на этапе выполнения(не существует типа данных))<- Благодаря virtual.Как только функция помечается virtual это значит что во всех дочерних классах метод который помечен в базовом классе будет virtual, даже если в дочернем классе перед типом данных того же метода нет virtual. 
	{
		m_height = h;
	}
	void SetWidht(int w) 
	{
		m_width = w;
	}
};
class Square : public Rectangle
{
public:

virtual	void SetHeight(int h)//Позднее связывание.Сигнатура метода( это часть интерфейса).
	{				
		Rectangle::SetHeight(h);
		Rectangle::SetWidth(w);
	}				
};
void main()
{
	Rectangle * p = new Square;//(ТУТ ПРОБЛЕМА МЕХАНИЗМА РАННЕГО СВЯЗЫВАНИЯ)называется ранее связывание(То есть на момент компиляции, компилятор смотрит на тип данных указателя(В нашем случаи это Rectangle)(и смотря что мы там запишем). то !->
	p -> SetHeight(6);//Называется ранее связывание !-> будет вызыватся метод из базового класса
	Square s;
	s.SetHeight(6);
}
----------------------------------------------------------------------------------------------------
Как работает ранее и позднее связывание:
Когда мы пишем virtual компилятор сам создает для класса таблицу виртуальных функций
Таблица виртуальных функций(Virtual Function Table) - ЭТО ДЕЛАЕТ КОМПИЛЯТОР САМ,когда мы ставим virtual в методе в одноуровнем наследовании(то есть 1 базовый класс и 1 дочеринй):
Колонка 1:								Колонка 2:
Название виртуального метода и адрес в памяти
Например:								Создается точно такая же таблица:
Rectangle:<-------------------------------------------------------------Square:
БылоSetHeight|8080 Стало virtual SetHeight|8080				SetHeight|Было:8080Стало: 9090(Как только ставится virtual в главном классе меняется адрес в памяти)(ЕЩЕ размер класса увеличится на один указатель virtual(Либо настолько указателей столько сколько создал virtual).То есть 1 virtual - 1 указатель, 2 virtual - 2 указателя и Так далее)Указатель называется - (__vptr) (туда помещается указатель на нужную таблицу виртуальных функций) 
SetWidth|8120								SetWidth|8120
----------------------------------------------------------------------------------------------------
Например:
Rectangle * ptr = new Square;
ptr -> SetHeight(6);
Компилятор модифицирует вызов(ptr -> SetHeight(6);) на примерно вот такой:
(*(ptr -> __vptr + 0))(6);
------------------------------------------------------------------------------------------------------
Указатель __vptr записывается в конструкторе, в конструкторе записывается корректный адрес __vptr нужной таблицы виртуальных функий. С++
С - malloc(И остальные С функции) не имеет в конструкторе корректного адреса __vptr таблицы виртуальных функций;
Например:
С
Rectangle * p = (Rectangle*) malloc(sizeof(Rectangle));
p -> SetHeight(6);//Если SetHeight виртуальный, то в адрессе __vptr будет мусор, следовательно при обращении будет ошибка.
----------------------------------------------------------------------------------------------------------
class Rectangle
{
	Rectangle()
	{
		SetHeight(10);//НИКОГДА НЕ ВЫЗЫВАЙТЕ ВИРТУАЛЬНЫЙ МЕТОД В КОНСТРУКТОРЕ, потому что в _vptr будет записана не правильная таблица виртуальных функций, так как сначала отработает конструктор базового класса, который хранит свой SetHeight и свою таблицу виртуальных функций, и это ошибка придет к нам в конструктор дочернего класса то есть Square().
	}
};
--------------------------------------------------------------------------------------------------------------
Дополнительные плюшки:
С++11
virtual void SetHeight(int h) override;//Я хочу переопределить метод(для этого override)(То есть с 1 дочернего класса и ниже).Переопределение - одинаковая сигнатура но разные реализации.
Переопределять можем только с virtual функциями и одинаковыми сигнатурами(полностью идентичные)
Также можно написать final(то есть это последнее переопределение).
virtual void SetHeight(int h) final;
------------------------------------------------------------------------------------------------------------
ОЧЕНЬ ВАЖНАЯ ПРОБЛЕМА:
class Rectangle
{
	int m_width;
	int m_height;
public:
virtual void SetHeight(int h)
	{
		m_height = h;
	}
	void SetWidht(int w) 
	{
		m_width = w;
	}
	virtual ~Rectangle(){};//РЕШЕНИЕ, еще нужно добавить перед именем деструктора virtual(Деструктор должен быть объявлен виртуально, если мы будем удалять объекты через указатели на базовый класс)  ( = default;//default C++11)
};
class Square : public Rectangle
{
public:

virtual	void SetHeight(int h)//Позднее связывание.Сигнатура метода( это часть интерфейса).
	{				
		Rectangle::SetHeight(h);
		Rectangle::SetWidth(w);
	}				
};
void main()
{
//Проблема нужно дописать код:
	Square s;
	Rectangle * p = new Square();//Позднее связывание так как virtual.
	p -> SetHeight(10);
	delete p;//РЕШЕНИЕ мы должны удалить память.
	Square s1
	Rectangle * = & s1;
	p -> SetHeight(6);
	delete p;//Удаляем спокойно,так как мы не создаем новый объект который имеет виртуальные методы.
}
------------------------------------------------------------------------------------------
Все по такому же принципу работает с ссылками, какие и указатели, пример:
void Draw(const Rectangle & r);
void main()
{
	Square s;
	Draw(s);
}
---------------------------------------------------------------
Rectangle (const Rectangle & source1)//В классе конструктор копирования
{
	//Алгоритм копирования
}
Square(const Square & source2) : Rectangle(sorce2)//РЕШЕНИЕ    (//Конструктор базового класса по умолчанию)
{
	
}
void main()
{
	Sqaure s1;
	Squae s2(s1);//Тут не указан конструктор копирования, по этому конструктор по умолчанию..
}
--------------------------------------------------------------------------