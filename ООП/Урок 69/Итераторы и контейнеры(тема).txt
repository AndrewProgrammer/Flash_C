Контейнер - это блок для хранения данных и управления ими(колекция данных), и разнообразные методы для работы с ней.Бинарное дерево - контейнер.
Итератор - специальный объект который позволяет перемещатся по данным контейнера.
Input iterator - с помощтю этого итератора читаются данные из контейнера(такие итераторы можно == != *i ++i).
output iterator - при помощи выходных итераторов можно записывать данные в контейнер( поддерживают все теже операции что и input iterator: == != *i = x ++i)
forward iterator - однонаправленный итератор, включает в себя функциональность output,input iterator.
bidirectional iterator - поддерживает дикрименты( то есть назад).
random access iterator - включает все и также еще: i+=n, i-=n,i-n, i1>i2,i1<i2,i1>=i2,i1<=i2.
------------------------------------
Подключаем файл #include <vector>
Например: std::vector <int> v(3,9);
vector(size_t n,T val = T());
Пустой вектор:
std::vector <int> v;
vector(size_t n,T val = T());
vector позволяет хранить в себе типы данных у которых нет конструктора по умолчания.
--------------------------------------
Методы вектора:v.size();//Возвращает размер
v.capactity();//Выделяет память на новый элемент
v.empty();//Проверка на пустоту объекта.
v[1];//Не кидает исключение
v.at(1);//Выкидывает exception.
v.push_back(7);//Добавляет значения в конец текущего вектора и плюс размер вектора увеличивается на 1.(То есть size будет уже равен 3+1=4)
-------------------------------------
Первый контейнер пример vector:
#include <vector>
void main()
{
	std::vector <int> v(3,9);
	//Добавляем 3 элемента в вектор
	v.push_back(3);
	v.push_back(6);
	v.push_back(8);
	vector<int>::iterator it = v.begin();//Для вектора будет тип данных объекта it ( iterator), и it создаст ссылку на первый элемент в векторе.
	vector<int>::iterator e = v.end();//Возвращает итератор за последнем элементом.
	//Полный обход абсолютно любого контейнера
	while(it!=e)
	{
		cout << *it;//Для того чтобы получить значения на которое ссылается итератор, то мы используем операцию разыменования.
		//если мы хотим вывести объект например:
		//vector<Student>
		//(*it).Show();
		//it->Show();
		//Если вот так vector<Student*> то:
		//(*(*it)).Show();
		//(*it)->Show();
		++it;
	}
}
//Можно написать еще так:
//vector <T> ar;
//ar T[];
//T*p = new T[];
--------------------------------------------
С помощью С++11:
auto it = v.begin();
auto e = v.end();
while(if!=e)
{
	cout << *it;
	++it;
}
-----------------------------------------------
Тот же цикл только от С++11 и выше и в других языках программирования:
//КАЖДЫЙ ЭЛЕМЕНТ БЕРЕТСЯ ПО ЗНАЧЕНИЮ!
for(int x:v)//Этот цикл пройдется по всему v и эти значения v запишутся в x и дальше мы выводим значения
{
	cout << x;
}
//Елси мы хотим использовать классы(то есть объекты, то пишем так)
//for(auto&x:v)
//for(int&x:v)
//Можно изменить цикл for_each или как он еще называется: range-based for
//for(int& x:v)
//{
//	x = 3;
//	cout << x;
//}
//На экране будет все колекция из троек(3).
---------------------------------------------------------------
Для того чтобы работал цикл for each  нужно:
//Методы:
T begin();
T end();
//Функции:
T begin(Array a);
T end(Array a);
//У шаблонного типа данных T должны быть перегруженные операторы:
!= // возвращает bool
* // вернет элемент колекции
++ // возвращает следующий итератор
Как примерно это будет работаеть:
void main()
{
	Array a;
	for(auto _b = begin(a), _e = end(a); _b != _e ; ++_b)
	{
		T x = *_b;//Записываем значение в x(x имеет любый тип данных)
		cout << x;
	}
}
-------------------------------------------------