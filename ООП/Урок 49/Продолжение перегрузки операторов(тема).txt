Перегрузка умных указателей:
class SmartPtr
{
private:
	int * m_ptr = nullptr;
public:
	SmartPtr(int & ptr):m_ptr(ptr)
	{
		int& operator*()//перегрузка оператора разыменования
		{
			return *m_ptr;	
		}
	}
	~SmartPtr()
	{
		delete m_ptr;	
	}
};
void main()
{
	SmartPtr p = new int;//проблема: можно поставить []
	*p = 7;
}
---------------------------------------------------------------------
Перегрузка оператора взятие адреса:
//У этого класса нельзя использовать оператор ->.
class SmartPtr
{
private:
	int * m_ptr = nullptr;
public:
	SmartPtr(int & ptr):m_ptr(ptr)
	{
		int& operator*()//перегрузка оператора разыменования
		{
			return *m_ptr;	
		}
	}
	SmartPtr(const SmartPtr&) = delete;//C++ 11 + оператор присваивания
	int** operator&()//
	{
		return &m_ptr;
	}
	~SmartPtr()
	{
		delete m_ptr;	
	}
};
void main()
{
	SmartPtr p = new int;//проблема: можно поставить []
	*p = 7;
	int** p2 = &p;//скомпилируется
	SmartPtr p3 = p;//Для решения нужно переместить конструктор копирования и оператор присваивания в private секцию//не разделяется память с другим указателем(Нужно запретить возмоэность копировать)
	//C++ 11 не будет работать как удаленная функция(удаленная функция - функция которая была удалена).
}
-------------------------------------------------------------------------------------------------------------------
unique_ptr//Означает один владелец у этой памяти и он обычно не позволяет копировать.
Перегрузка оператора ->(применяется только к указателям):
class SmartPtr
{
private:
	int * m_ptr = nullptr;
public:
	SmartPtr(int & ptr):m_ptr(ptr)
	{
		int& operator*()//перегрузка оператора разыменования
		{
			return *m_ptr;	
		}
	}
	SmartPtr(const SmartPtr&) = delete;//C++ 11 + оператор присваивания
	int* operator ->()//Возвращается указатель так как -> работает с указателем.
	{
		return m_ptr;
	}
	int** operator&()//
	{
		return &m_ptr;
	}
	~SmartPtr()
	{
		delete m_ptr;	
	}
};
void main()
{
	SmartPtr p = new int;//проблема: можно поставить []
	*p = 7;
	int** p2 = &p;//скомпилируется
	SmartPtr p3 = p;//Для решения нужно переместить конструктор копирования и оператор присваивания в private секцию//не разделяется память с другим указателем(Нужно запретить возмоэность копировать)
	//C++ 11 не будет работать как удаленная функция(удаленная функция - функция которая была удалена).
}
//Если p2 -> то комплиятор возвращается к оператору нашему стрелка, и потом мы выводим указатель в мейне к которому уже можно использовать -> уже для него.
raw pointer - также еще их называют указатель
//Перевое решение проблемы если много указателей на объект и нужно удалить их все вместе с объектом когда указатель самостоятельно каждый раз сам хочет удалить объект.
