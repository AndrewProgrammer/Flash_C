Шаблоны функций - позволяет описать функцию и написать реализацию тела функции без точного типа данных.
Шаблоны - один из вариантов мета программирования(вы пишете код который создает другой).
Шаблоны просто так не компилируется в машинный код и не хранятся в exe.
Создается экземпляр шаблонной функции если он используется либо вызывается в программе
Синтаксис шаблона:
template означает что мы пишем шаблон(ключевое слово для шаблона)
typename - шаблонный тип
template <typename(также можно записать class) T,typename U(Любое имя типа данных) >
Дальше наша сигнатура функций но там можно написать T
Например:
T(любой тип данных) Sum(T a, T b)
{
	//T res = a + b;
	//return res;
	return a + b;
}
void main()
{
	int a = 3;
	int b = 4;
	int c = Sum<int>(a,b);//Тут будет приводится только к int
	int d = Sum(a,b);//Компилятор будет сам использовать тип данных который он хочет
	//Если у нас одна переменная шаблона и туда входят два типа данных, то это проблема!!!
	//Если я передаю например int c = Sum(Foo(a))// то у T будет тип данных который в Foo
	int p = Sum(1.0,2.5);//Тип данных double
}
С помощью такого подхода мы выйграли размер кода то есть вместо одной функции суммы для 8 типов данных мы пишем один.
Преимущества перегрузки перед шаблонной функции, в том что для перегрузки для каждого разного типа данных мы можем использовать разную реализацию а для шаблонов мы используем одну реализацию для всех типов данных.
Можно использовать прототип.
Ограничения:
1)Шаблоны нельзя разносить по двум файлам Header and cpp
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
C++11 
auto:(Ключевое слово)
auto a = c + b;//Тип переменной a вычеслиться из с + b
decltype(ключевое слово)
decltype (a + b )(Слева тип данных) c; (вычесляет тип данных)
C++14 - 17(C++11)
trailing return type - хвостовое возвращаемое значение
int Sum(int a, int b);//Сигнатура функции
auto Sum(int a , int b) -> int;//Сигнатура той же самой функции только с помощью trailing return type
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template < typename T, typename U>
auto Sum(T a , U b) -> decltype(a + b);
Можно писать шаблонные методы тоже.
----------------------------------------------------------------------------------------------------------------------
Перегрузка шаблонов функции
/Компилятор саначало находит функцию со стандартным типом данных, а потом ищет шаблоны.
T(любой тип данных) Sum(T a, T b)
{
	//T res = a + b;
	//return res;
	return a + b;
}
T(любой тип данных) Sum(T a, T b, T c)
{
	//T res = a + b;
	//return res;
	return c = a + b;
}
int Sum(int a, int b);//+ Тело(ПРИОРИТЕТНЕЕ)
---------------------------------------------------------------------------------------------
Практика:
template <typename T>
T Sum ( int a, int(T - можно поставить) b) {return a + b};//Все отработает
void main()
{
	Sum(1,2);//Не скомпилируется!
}
T Sum ( int a, int b) {return a + b};//Все отработает
void main()
{
	Sum<int>(1,2);//Скомпилируется!
}