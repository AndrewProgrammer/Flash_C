перегрузка операций(операторы)
operator overload
Перегрузка операторов - вариант статического полиморфизма, перегружать операторы необходимо для того чтобы реализовать статический полиморфизм и чтобы внедрить компоненты уже в существующую систему(подсистему).
Перегружать операторы можно перегружать 2 способами:
1)Как метод класса.
2)Как функция(глобальная функция).
Ограничения перегрузки операторов:
1)Не все операторы возможно перегрузить(Например: оператор (:),(.*),(.)(тернарный оператор - (? :)),(;),(())),. 
2)Нельзя придумывать свои операторы(Например:(**),(<>))
3)Нельзя менять приоретет существующих операторов.
4)Нельзя изменить количевство операндов у операторов.(Если перегружать &&,||(они имеют полную форму) - то мы теряем их функциональность по сокращенной форме).
Колчевство аргументов у метода перегрузки оператора на 1 меньше чем количевство операндов у этого оператора.
Операнды бывают - унарные(принимают один) и бинарные(принимают 2).
Если оператор бинарный - левый операнд this;
Синтаксис перегрузки операторов как метод класса:
class Int
{
	//С помощью метода класса
	int value;
public:
	Int operator /(int right)//с explicit так как у нас тип данных int
	Int operator /(Int right)//без explicit
	{
		return Int(value / right.value);
	}
};
void main()
{
	Int a,b;
	Int c = a/b;
	//Int c = a / 3;(На самом деле Int(3)),если есть explicit то не заработает.
	//Int c = 3/b;Не скомпилируется так как integer и Int.Если Int c = Int(3) / b; -все нормально.
	Int c = a.operator /(b- сюда передается правый операнд,нельзя левый);//Компилятор преобразует вот в такую запись
}
Синтаксис перегрзуки операторов как функция:
class Int
{
	int value;
public:
};
//глобальная функция работает с классом,если мы не имеем доступа к левому операнду
// если бинарный - то два, если унарный то один
Int operator+(Int left, Int right)
{
	return Int(left.value + right.value);
}
explicit Int operator+(int left, Int right) // Если 3/b - не работает
{
	return Int(left.value + right.value);//Важно количевство аргументов и их типов.
}
void main()
{
	Int c = 3/a;//работает
	Int c = a/b;//работает
	Int c = a/3;//работает
	Int c = 3/b;//работает
}
Операторы могут быть константными и также передавать аргументы по сылке или указателю
Советы по перегрузки операторов:
1)Никогда не перегружайте оператор если это не логично
2)Операторы менее информативные чем методы
3)Для некоторых операторов у нас будет выбор при перегрузки как глобальная функция или как метод - класса
4)Если оператор не модифицирует значение своих аргументов то желательно его перегружать как глобальную функцию.
5)Вы не должны менять семантику операторов.Например(int - принимает аргумент типа данных,int - принимает аргумент типа данных и получаем возвращаемое значение не int)
Есть некоторые операторы которые можно перегрузить только через метод класса.Например: Оператор присваивания,оператор [], оператор -> .
------------------------------------------------------------------------------
Статический полиморфизм - код одинаковый но при нем происходят разные вещи.

if(ar[i] > ar[i+1])//Из сортировки пузырьков
	swap();
------------------------------------------------------------------------------
Оператор присваивания(=).
В любом лкассе есть оператор присваивания(Он реализован компилятором по умолчанию,предоставляет побитовое копирование)
Если в классе присутствуют динамические и не динамические поля мы их должны реализовать
Множественное присваивание: a=b=c=3;
Конструктор копирования вызывается для нового объекта.
А оператор присваивания для уже нового объекта.
Сигнатура оператора присваивания:
class Human
{
	Human& operator =(const String& right);//Оператор присваивания может быть перегржен разными методами.
	Human& operator =(const Human&right);//Оператор присваивания,const нельзя так как мы изменяем объект
	{
		//4 шага по реализации метода оператора присваивания:
		if(this != &right)//1)Проверяем не присваиваем мы себя себе же
		{
			delete[] m_name;//2)Очестка ресурсов динамических тому объекту к которому присваиваем.Все то же самое что и в деструкторе(Вынести в какой то метод)
			m_name = new char[strlen(right.m_name)+1];//3)копирования нового состояния объекта(Конструктор копирования)
			strcpy(m_name,right.m_name);//3)копирования нового состояния объекта(Конструктор копирования)
			m_age = right.m_age;//3)копирования нового состояния объекта(Конструктор копирования)
			//тоже можно вынести в отдельный метод например: void Assign(const Human& human);
			//Dispose();Assign(); будет всеголишь в if(this != &right)
			return *this;//4)возвращаемое значение,для того чтобы иметь возможность множественного присваивания,разыменования указателя this(Мы получаем сам объект Human)Левый операнд.
		}
	}
};
Оператор присваивания необходим для того чтобы полность описать конструктор копирования,деструктор и присваивание.Реализуется только в виде метода класса.