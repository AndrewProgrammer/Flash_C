Перегрузка оператора ++ в префиксной и постфиксной форме:
Int& operator ++()//перегрузка оператора префиксная форма
{
	++value;
	return *this;
}
Int operator++(int(для того чтобы компилятор понял что это перегрузка оператора постфиксной форсы))//перегрузка оператора постфиксной формы
{
	Int copy = *this;
	++value;
	return  copy;
}
----------------------------------------------------------
Перегрузка оператора [](Может перегружен как оператор для чтения, а также как присваивание)(должен быть перегружен только как метод класса):
char operator[](int index(Сдесь может быть любой тип данных))const//Строка на чтение(Работает как перегрзука, так как const обозначает что уже работает перегрзука)
{
	if(index>=0 && index < m_length)//память массива
		return m_string[index];		
}
char& operator[](int index)//Строка на запись
{
	if(index>=0 && index < m_length)//память массива
		return m_string[index];	
}
void main()
{
	String s(...);
	s[0] = 'x';
	cout << s[1];
	F(const String&);//будет вызыватся константная перегрузка оператора[]
	F(s);
}
--------------------------------------------------------
rvalue - временные объекты им нечего нельзя присваивать.
Оператора преобразавания к типу type cast(преобразавание):
explicit(C++11) operator int(сдесь может быть любой тип данных)()const
{
	return atoi(m_string);		
}
operator Date()const//Пример сигнатуры
void main()
{
	String s(...);
	int a = (int)s;//можно только в с explicit (С++11)
	int a = s;//можно
	String s("10.10.2010");
	
}
---------------------------------------------------------
Оператор круглые скобки()
Объект передать в качевстве параметра и у которого будет алгоритм например сортировки по имени или по фамилии. 
Он нужен для того чтобы сделать объект как функцию.
Функторы - объекты которые выглядят как функции.
void(любой тип данных) operator()(int a, int b, int c(любые аргументы с типами данных)
{
	//то что посчитаем нужным
}
---------------------------------------------------------
Перегрузка операторов new и delete(C++)
New - вызывает malloc а потом вызывает конструктор.
Delete - вызывает деструктор а потом free.
malloc - принимает в байтах.
calloc - в элементах.
void* - это указатель который повзволяет в себе хранит адрес любого типа данных, но при этом вы не можете разыменоватся.
Базовый тип указателя - нужен для того чтобы корректно разыменоватся.
Для того чтобы создать новую память для работы со своим объектом.Например: Создать огромный кусок памяти, и работать со своим объектом.
Статические методы для класса:
void* operator new(size_t cout)//Статический метод
{
	Int* ptr = (Int*) malloc (sizeof(Int));
	return ptr;	
}
void operator delete(void* ptr)//Статический метод//Удаляет созданную нами память
{
	free(ptr);	
}
Для того чтобы создать vfccbd новую память для работы со своим объектом.Например: Создать огромный кусок памяти, и работать со своим объектом.
void* operator new[](size_t cout)//Статический метод
{
	Int* ptr = (Int*) malloc (sizeof(Int) * count);
	return ptr;	
}
void operator delete[](void* ptr)//Статический метод//Для удаления массива нашей памяти
{
	free(ptr);	
}
---------------------------------------------------------
Оператор вывода объекта на консоль
operator <<(std::ostream& os(cout), const String& s(наш объект))
{
	os << s.GetCString();
	return os;	
}
void main()
{
	Stirng s;
	cout << s;//можно
	cout << s << s2;//можно
}
-------------------------------------------------------
Оператор ввода объекта в консоль
std :: istream& operator >>(std::istream& is, String& s)
{
	is.getline(s.m_string);
	return is;
}