#include <iostream>
using namespace std;

void main ()
{
	/*
				Операторы отношения - бинарные операторы, которые проверяют два значения на отношение и возвращают логическое значение: true - если отношение выполняется,
						false - отношение не выполняется.

				Операторы отношения:
					>            -  больше
					<            -  меньше
					>=           -  больше или равно
					<=           -  меньше или равно

				При этом, приоритет этих операторов НИЖЕ чем у арифметических. То есть, выражение:
					5 + 2 > 6
				будет true, посколько сначала выполнится сложение 5 + 2, а затем проверка отношения.
	*/

	int iVal1 = 5, iVal2 = 10;
	cout << "iVal1 = " << iVal1 << endl;
	cout << "iVal2 = " << iVal2 << endl;

	cout << "--------------------------------------\n";
	cout << "iVal1 < iVal2: " << (iVal1 < iVal2) << endl;
	cout << "iVal1 > iVal2: " << (iVal1 > iVal2) << endl;
	cout << "--------------------------------------\n";

	iVal1 = 10;
	cout << "iVal1 = " << iVal1 << endl;
	cout << "iVal2 = " << iVal2 << endl;
	cout << "iVal1 <= iVal2: " << (iVal1 <= iVal2) << endl;
	cout << "iVal1 >= iVal2: " << (iVal1 >= iVal2) << endl;
	cout << "--------------------------------------\n";

	iVal1 = 15;
	cout << "iVal1 = " << iVal1 << endl;
	cout << "iVal2 = " << iVal2 << endl;
	cout << "iVal1 + 2 <= iVal2: " << (iVal1 + 2 <= iVal2) << endl;
	cout << "iVal1 >= iVal2 - 1: " << (iVal1 >= iVal2 - 1) << endl;
	cout << "--------------------------------------\n";


	/*
				Операторы сравнения - это бинарные операторы, которые проверяют два значения на равенство или неравенство и возвращают логический результат.

				Операторы сравнения:

					==				- равно
					!=				- не равно

				Пример:

					5 == 2  // false, т.к. 5 не равно 2!
					5 == 5  // true, т.к. 5 равно 5
					5 != 5  // false, т.к. неравенство не выполняется
					5 != 2  // true, т.к. неравенство выполняется
	*/
	
	cout << "iVal1 = " << iVal1 << endl;
	cout << "iVal2 = " << iVal2 << endl;

	cout << "iVal1 == iVal2:\t\t" << (iVal1 == iVal2) << endl;
	cout << "iVal1 == iVal2 + 5:\t" << (iVal1 == iVal2 + 5) << endl;
	cout << "iVal1 != iVal2:\t\t" << (iVal1 != iVal2) << endl;
	cout << "iVal1 != iVal2 + 5:\t" << (iVal1 != iVal2 + 5) << endl;
	cout << "--------------------------------------\n";
	cout << "--------------------------------------\n";

	/*
				Логические операторы:

				Оператор "НЕ" (Отрицание)			!
				Оператор "И"						&&
				Оператор "ИЛИ"						||

			Логические операторы, в отличие от других, в качестве операндов ожидают значение логического типа. И даже если будет передано значение другого типа данных, 
			оно все равно будет преобразовано в логический. То есть, например, операндами && будут не 2 числа, а 2 логических значения.
	*/


	/*
			Оператор "НЕ" (!)

			Оператор отрицания является унарным логическим оператором. Выполняет логическое отрицание значения.
			Пример:
				!true		// результат false
				!false		// результат true

				!28			// 28 будет преобразовано в логический тип, в результате преобразования будет true, а !true даст в итоге false
				!-34		// над числом 34 поработает оператор минус(унарный), затем -34 будет преобразовано в логический тип, в результате преобразования будет true, а !true даст в итоге false
				!0			// 0 будет преобразован в логический тип, в результате преобразования будет false, а !false даст в итоге true
	*/

	cout << "!true:\t" << !true << endl;
	cout << "!false:\t" << !false << endl;
	cout << "!28:\t" << !28 << endl;
	cout << "!-34:\t" << !-34 << endl;
	cout << "!0:\t" << !0 << endl;
	cout << "--------------------------------------\n";
	cout << "--------------------------------------\n";

	/*
			Оператор "И" (&&)

			Оператор "И" - бинарный. Он проверяет два своих операнда, и в том случае, если оба имеют значение true - возвращает true. В остальных случаях false:

			1 операнд | && | 2 операнд | Результат
			true	  | && | true	   | true
			true	  | && | false     | false
			false	  | && | true	   | false
			false	  | && | false	   | false

			При этом приоритет у оператора "И" НИЖЕ чем у операторов сравнения и отношения и тем более ниже чем у арифметических операторов.
	*/

	cout << "true && true: \t" << (true && true) << endl;
	cout << "true && false: \t" << (true && false) << endl;
	cout << "false && true: \t" << (false && true) << endl;
	cout << "false && false: \t" << (false && false) << endl;
	cout << "5 < 2 && 5 > 3: \t" << (5 < 2 && 5 > 3) << endl; // 5 < 2 - false, 5 > 3 - true... В итоге false && true получается false
	cout << "5 > 2 && 5 > 3: \t" << (5 > 2 && 5 > 3) << endl; // 5 > 2 - true, 5 > 3 - true... В итоге true && true получается true
	cout << "5 > 2 && 5 > 3 && 2 == 0: \t" << (5 > 2 && 5 > 3 && 2 == 0) << endl; // 5 > 2 - true, 5 > 3 - true... true && true получается true. 2 == 0 - false. 
	// В итоге, true от первого подвыражения и false от второго: true && false получается false

	cout << "--------------------------------------\n";
	cout << "--------------------------------------\n";

	/*
	Оператор "ИЛИ" (||)

	Оператор "ИЛИ" - бинарный. Он проверяет два своих операнда, и в том случае, если ХОТЯ БЫ ОДНО имеет значение true - возвращает true. В остальных случаях false:

	1 операнд | || | 2 операнд | Результат
	true	  | || | true	   | true
	true	  | || | false     | true
	false	  | || | true	   | true
	false	  | || | false	   | false

	При этом приоритет у оператора "ИЛИ" НИЖЕ чем у операторов сравнения и отношения и тем более ниже чем у арифметических операторов.
	*/

	cout << "true || true: \t" << (true || true) << endl;
	cout << "true || false: \t" << (true || false) << endl;
	cout << "false || true: \t" << (false || true) << endl;
	cout << "false || false: \t" << (false || false) << endl;
	cout << "5 < 2 || 5 > 3: \t" << (5 < 2 || 5 > 3) << endl; // 5 < 2 - false, 5 > 3 - true... В итоге false || true получается true
	cout << "5 < 2 || 5 < 3: \t" << (5 < 2 || 5 < 3) << endl; // 5 < 2 - false, 5 < 3 - false... В итоге false || false получается false
	cout << "5 < 2 || 5 > 3 || 2 == 0: \t" << (5 < 2 || 5 > 3 || 2 == 0) << endl; // 5 < 2 - false, 5 > 3 - true... false || true получается true. 2 == 0 - false. 
	// В итоге, true от первого подвыражения и false от второго: true || false получается true


	// При этом приоритет у оператора ИЛИ (||) НИЖЕ чем у оператора И (&&), соответственно, следующее выражение будет работать корректно даже без скобок!

	cout << "5 < 2 && 5 < 3 || 2 != 0 && 2 == 2: \t" << (5 < 2 && 5 < 3 || 2 != 0 && 2 == 2) << endl; // Аналогично выражению: (5 < 2 && 5 < 3) || (2 != 0 && 2 == 2)
	// Порядок вычисления: 5 < 2 -> false, 5 < 3 ->  false... false && false в итоге false.  
	// 2!= 0 -> true, 2 == 2 -> true... true && true в итоге true.
	// false || true в результате даст true


	cout << "--------------------------------------\n";
	cout << "--------------------------------------\n";

	// Операторы "И" и "ИЛИ" работают в языке С по сокращенной схеме. Т.е. если на каком-то этапе вычисления уже понятен результат, то выражение дальше вычисляться не будет.
	// Пример:
	cout << "5 < 2 && 2 == 2:\t" << (5 < 2 && 2 == 2) << endl; // 5 < 2 - false... Уже сразу понятно, что в итоге результатом "И" будет false. Подвыражение 2 == 2 НЕ ВЫЧИСЛЯЕТСЯ.
	cout << "5 > 2 || 2 == 2:\t" << (5 > 2 || 2 == 2) << endl; // 5 > 2 - true... Уже сразу понятно, что в итоге результатом "ИЛИ" будет true. Подвыражение 2 == 2 НЕ ВЫЧИСЛЯЕТСЯ.
}