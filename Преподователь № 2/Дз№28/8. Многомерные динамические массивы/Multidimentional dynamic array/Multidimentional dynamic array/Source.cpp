#include <iostream>
#include <ctime>
using namespace std;

/*
	Оператор new позволяет выделить блок памяти определенного размера и используя арифметику указателей и оператор разыменования
		можно пользоваться этим блоком как одномерным массивом.
	
	Однако, в случае, когда необходимо выделить память под многомерный массив - возникает ряд неприятностей.
	В многомерном массиве, очевидно, присутствует несколько размерностей, следовательно - для доступа к элементу многомерного массива
		требуется несколько операций индексирования. Каждая операция индексирования неявно преобразуется в оператор разыменования и 
		арифметическую операцию над указателем. 

		Предположим, что мы хотим сделать двумерный динамический массив 3х3. Следовательно нам понадобиться память под 9 элементов.
		Можно написать следующий код:

			int* myArray = new int[9];
		Однако, мы получаем обычный указатель на int. Следовательно, после первого разыменования - уже получим объект типа int, который нельзя будет 
			применить второе разыменование. Другими словами, используя эту простую стратегию мы можем работать только с одномерными массивами.
			Если нужна многомерность - необходимо делать её самостоятельно высчитывая смещения.


		
		Но есть несколько подходов для построения настоящего многомерного динамического массива.

		Подход 1:
			
			1. Выделяем память под массив указателей (!), каждый элемент этого массива будет ссылаться на массив меньшей размерности.
					Например, в случае двумерного массива, каждый элемент этого массива будет указывать на соответствующую ему строку.
					Другими словами, в случае двумерного массива - выделяем массив строк.
			2. Для каждого подмассива выделяем память.
					Например, в случае двумерного массива - для каждой строки выделяем массив элементов.
*/


void main ()
{
	srand (time (0));

	int numRows = 0, numCols = 0;

	cout << "Enter number of rows: ";
	cin >> numRows;

	cout << "Enter number of cols: ";
	cin >> numCols;

	// Выделяем динамически массив указателей. Каждый элемент этого массива - указатель.
	int **pRowsArray = new int*[numRows];

	for (int i = 0; i < numRows; i++)
	{
		// Для каждой строки массива выделяем элементы.
		pRowsArray[i] = new int[numCols]; 
	}


	for (int i = 0; i < numRows; ++i)
	{
		for (int j = 0; j < numCols; ++j)
		{
			pRowsArray[i][j] = rand () % 51; // pRowsArray[i] - индексирует массив указателей и достает указатель на соответствующую строку. 
														//	 [j] - индексирует конечный массив и достает элемент

			cout << "[" << i << "][" << j << "] = " << *(*(pRowsArray + i) + j) << "\t"; //  *(*(pRowsArray + i) + j) и  pRowsArray[i][j] это эквивалентные записи
		}
		cout << endl;
	}


	// Процесс удаления такого массива не так прост как раньше. Процесс обратный выделению памяти под такой массив.
	for (int i = 0; i < numRows; i++)
	{
		// Очищаем память, выделенную под каждую строку массива.
		delete[] pRowsArray[i];
	}

	// Затем очищаем память, выделенную под массив указателей на строки двумерного массива.
	delete[] pRowsArray;
}


/*
	Одно из достоинств этого подхода - формирование каждой строки массива отдельно. Что позволяет создать т.н. "зубчатый массив", где размер одной строки,
		может отличаться от размера другой.

	Недостаток этого подхода - большое количество операций по выделению памяти и освобождению памяти. Это дорогостоящие операции и чем больше массив, тем больше
		времени будет отдано на выполнение этих операций.
*/