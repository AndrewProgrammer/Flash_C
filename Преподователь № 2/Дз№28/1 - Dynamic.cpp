#include <iostream>
using namespace std;

void main ()
{
	/*
		В С/С++ присутствует возможность динамического выделения памяти.
		
		Применяя статическое выделение памяти, размер блока памяти должен быть известен на этапе компиляции (например, размер массива).

		В случае динамического выделения памяти - размер блока памяти, который необходимо выделить, определяется на этапе выполнения программы.
		Соответственно, мы получаем ручной контроль за использованием памяти. В любой момент можем выделить блок произвольного размера,
			в любой момент можем удалить.

		Использование динамического выделения памяти позволяет создавать динамические структуры данных, например динамические массивы.

		Динамические объекты распологаются в специальной области памяти, которая называется "куча" (англ. heap).

	*/

	/*
		Для динамического выделения блока памяти в куче применяется оператор new.
		Оператор new выделяет блок памяти определенного размера и возвращает указатель на данный участок памяти.		
	*/

	int *pDynVar = new int; // Выделяем динамически 4 байта под переменную типа int
	// Оператор new выделил 4 байта памяти и вернул указатель на первый байт этого блока
	
	cout << "Dynamic int variable: " << *pDynVar << endl;

	*pDynVar = 12; // Записываем в динамическую переменную значение 12

	cout << "Dynamic int variable: " << *pDynVar << endl;


	/*
		Каждый объект выделенный динамически должен быть вручную уничтожен!!! Никто за Вами убирать не будет.
		Если объект не уничтожить руками, он останется до закрытия программы. 
		Следовательно, проявляется эффект, который называется "утечка памяти". Когда память выделяется, но не уничтожается.
		Соответственно, Ваша программа будет всё больше и больше памяти потреблять с каждым выделением через "new", но не будет отдавать
			эту память обратно системе.

		Для того чтобы освободить используемую память необходимо воспользоваться оператором delete.
	*/

	delete pDynVar; // Освобождаем участок памяти, на который указывает pDynVar
	//delete pDynVar; // Если Вы попытаетесь освободить память ещё раз, то произойдет ошибка на этапе выполнения! Т.к. память уже была освобождена ранее
	
	// ВАЖНО! Повторный delete к одному и тому же участку памяти приводит к ошибке на этапе выполнения!
	// Чтобы этого избежать, разумеется надо следить за этим. Однако, существует тактика, которая позволяет защититься от невнимательности к этому вопросу.
	// После применения оператора delete рекомендуется в указатель, который указывал ранее на участок дин. памяти записать нулевой указатель!

	pDynVar = NULL; // Тогда Вы гарантировано не обратитесь к уже освобожденному участку памяти
	delete pDynVar; // И оператор delete примененный к нулевому указателю ошибки на этапе выполнения НЕ ДАСТ!!!



	double *pDynDoubleVar = new double (10); // Выделяем динамически блок памяти на 8 байт и записываем туда значение 10
	cout << "Dynamic double variable: " << *pDynDoubleVar << endl;
	delete pDynDoubleVar; // Освобождаем занимаемую память

}