#include <iostream>
#include <ctime>
using namespace std;

/*
	Второй подход по формированию двумерного массива, чуть менее прозрачен в реализации, и требует дополнительных действий для организации "зубчатого массива". 
	В данном примере будет показана простая реализация для обычного двумерного массива, где количество столбцов одинаково для каждой строки.
	
	Преимуществом данного подхода является существенно меньшее кол-во операций выделения памяти и освобождения памяти.
*/

void main ()
{
	srand (time (0));

	int numRows = 0, numCols = 0;

	cout << "Enter number of rows: ";
	cin >> numRows;

	cout << "Enter number of cols: ";
	cin >> numCols;

	// Выделяем динамически массив указателей на строки массива. Каждый элемент этого массива - указатель.
	int **pRowsArray = new int*[numRows];

	int *pActualArray = new int[numRows * numCols]; // Выделяем память под двумерный массив, храня его в памяти как одномерный

	for (int i = 0; i < numRows; i++)
	{
		// Заполняем массив указателей на строки.
		// Записываем в каждый элемент массива указатель на начало строки как в двумерном массиве, но поскольку по факту массив хранится как одномерный в памяти
		//	высчитываем соответствующее смещение для каждой строки. Найдя адрес начала новой строки, записываем его в массив указателей.
		pRowsArray[i] = pActualArray + i*numCols;
	}
	
	// Далее, работа с таким массивом аналогична предыдущему варианту.

	for (int i = 0; i < numRows; ++i)
	{
		for (int j = 0; j < numCols; ++j)
		{
			pRowsArray[i][j] = rand () % 51; // pRowsArray[i] - индексирует массив указателей и достает указатель на соответствующую строку. 
														//	 [j] - индексирует конечный массив и достает элемент

			cout << "[" << i << "][" << j << "] = " << *(*(pRowsArray + i) + j) << "\t"; //  *(*(pRowsArray + i) + j) и  pRowsArray[i][j] это эквивалентные записи
		}
		cout << endl;
	}

	// Очищаем память выделенную под фактический массив
	delete[] pActualArray;  // Или же: delete [] *pRowsArray;

	// Затем очищаем память, выделенную под массив указателей на строки двумерного массива.
	delete[] pRowsArray;
}

/*
	Основным преимуществом данного подхода является существенно меньшее кол-во операций для выделения памяти.

	Основный недостатком: если необходимо будет добавить строку или даже 1 элемент в данный массив,
		придется удалять весь массив и выделять память под новый массив.

	В предыдущем подходе достаточно будет перераспределить массив указателей, который существенно меньше.


	Выводы:
		Если у Вас предполагаются слишком частые добавления/удаления элементов из многомерного дин.массива, или необходимо создать "зубчатый массив",
			то рекомендуется использовать первый подход.

		Если же количество элементов относительно стабильно, и лишние операции по освобождению/выделению памяти слишком дороги - рекомендуется использовать
			второй подход.
*/