#include <iostream>
using namespace std;

/*
	В языке С++ присутствует механизм ссылок (reference).
	
	Ссылки - это идентификатор специального ссылочного типа, который ссылается на некий объект. 
		Через ссылку можно получить доступ к исходному объекту. Ссылочные типы менее функциональны чем указательные, но более безопасные.
	Проще говоря, ссылка - это псевдоним (другое имя) для одного и того же объекта.
	
	Объявление ссылки:
		тип & имя = объект;

		Где:
			тип - любой из существующих типов данных
			имя - идентификатор (имя ссылки), псевдоним для целевого объекта
			объект - некий объект в оперативной памяти, указанного типа, на который будет ссылаться этот идентификатор (либо обычное значение, но ТОЛЬКО const тип &)
						(Примечание: нельзя сделать ссылку на литерал, кроме случая, когда это константная ссылка: const тип&)

*/


void main ()
{
	int value = 10;

	int& valueRef = value; // Создаем ссылку на int переменную (int &), теперь valueRef - второе имя для переменной value
	valueRef = 15;

	cout << value << endl; // 15, т.к. мы через ссылку поменяли исходный объект

	// int& wrongRef; // Ошибка компиляции! При объявлении ссылки обязательно нужно указать объект на который она ссылается. 
						// Т.к. ссылка не является переменной. Это псевдоним. Её нельзя переназначить в будущем.


	// int &wrongRef2 = 10; // Ошибка компиляции! 10 - это литерал, а не объект в оперативной памяти. Нельзя сделать не него ОБЫЧНУЮ ссылку.
							// Т.к. по ссылке на int (int &) можно изменить объект. Однако литерал не хранится в ОЗУ и неизменен соответственно.

	const int &tenRef = 10; // Допустимо. Т.к. по константной ссылке запрещено менять исходный объект - это работает. По сути даем псевдоним литералу 10.
	cout << tenRef << endl;

	// tenRef = 15; // Ошибка компиляции! Это константная ссылка, менять по ней ничего нельзя.

	int someVar = 5;
	cout << "Address of someVar: " << &someVar << endl; // Берем адрес переменной someVar (Внимание! Оператор взятия адреса (&) и символ амперсанда при объявлении ссылки - совершенно разные лексемы!)
	 
	int &someRef = someVar; // someRef ссылается на someVar
	cout << "Address of someRef: " << &someRef << endl; // Адреса совпадут! Т.к. ссылка не является переменной и не хранится в оперативной памяти. Это псевдоним. 
							// Соответственно &someVar и &someRef - эквивалентные выражения!

	cout << "\n==========================================\n\n";



	// Давайте прочувствуем разницу в работе, на примере передачи аргументов в функцию.
	// Объявим три функции:

	void SwapByValue (int first, int second);		// Передача аргументов по значению. Значения копируются в локальные переменные-аргументы функции.
	void SwapByPointer (int *first, int *second);	// Передача аргументов по указателю. В функцию копируются адреса исходных объектов. 
	void SwapByReference (int &first, int &second);	// Передача аргументов по ссылке. Аргументы в функции являются ссылками (псевдонимами) на оригинальные объекты из вызывающего кода.

	int a = 1, b = 2;
	cout << "Before swap: a = " << a << " b = " << b << endl;
	cout << "SwapByValue..." << endl;
	SwapByValue (a, b);
	cout << "After wap: a = " << a << " b = " << b << endl;
	cout << "\n==========================================\n\n";

	a = 1; b = 2;

	cout << "Before swap: a = " << a << " b = " << b << endl;
	cout << "SwapByPointer..." << endl;
	SwapByPointer (&a, &b);
	cout << "After swap: a = " << a << " b = " << b << endl;
	cout << "\n==========================================\n\n";

	a = 1; b = 2;
	cout << "Before swap: a = " << a << " b = " << b << endl;
	cout << "SwapByReference..." << endl;
	SwapByReference (a, b);
	cout << "After swap: a = " << a << " b = " << b << endl;
	cout << "\n==========================================\n\n";

}

void SwapByValue (int first, int second)
{
	int temp = first;
	first = second;
	second = temp;
}

void SwapByPointer (int *first, int *second)
{
	if (first == NULL || second == NULL)
		return;

	int temp = *first;
	*first = *second;
	*second = temp;
}

void SwapByReference (int &first, int &second)
{
	// Работаем с объектами, на которые ссылаются first и second.
	int temp = first; 
	first = second;
	second = temp;
}
// Преимуществом передачи аргументов по ссылке является упрощение синтаксиса и безопасность.
// Не нужно разыменовывать указатели и беспокоится о корректности адреса (null указатели).