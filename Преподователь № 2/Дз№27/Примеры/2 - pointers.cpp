#include <iostream>
using namespace std;

/*
	Указатели являются одним из важнейших аспектов языков С и С++. Благодаря указателям можно достичь такой эффективности программы,
		которая недоступна для программ, написанных на других высокоуровневых языках. Некоторые вещи можно реализовать только через указатели,
		и никак по-другому.

	Указатель - это переменная (специального указательного типа), которая хранит числовой адрес другой переменной.
	Для того, чтобы обратиться косвенно, к объекту (переменной), адрес которого хранится в указателе, 
		необходимо к указателю применить оператор разыменования (dereferencing) (разадресация, оператор ссылки по указателю (indirection))  (*).


	Зачем для указателя базовый тип?
		Например:

			int someVar = 10;
			int *pInt = &someVar; // Указываем на переменную someVar
			*pInt = 25; // Разыменовывая pInt, получаем доступ к переменной someVar (т.к. pInt) указывает на someVar. Меняем переменную someVar
			cout << someVar << endl; // Выведет 25

			int b = 30;
			pInt = &b; // Теперь pInt указывает уже на b
			cout << *pInt << endl; // Выведет 30

	Так зачем указателю базовый тип? Почему был определен указатель как "указатель на int" (int *), почему не double *?
	Ведь адрес то всегда одинаковое количество байт занимает, и хранится одинаково, зачем тип менять?
	Однако, есть на то вполне очевидная причина.
	Когда мы делаем следующее:

	int *pInt = &b;
	То в указатель pInt записывается адрес переменной b. А точнее, адрес первого байта(!) переменной b.
	Поскольку b это int, то в ней 4 байта.
	При разыменовании нужно же знать сколько байт взять?

	Допустим, что &b вернуло 132. Т.е. адрес первого байта переменной b - это 132.
	Соответственно, если b имеет тип int, то в ней 4 байта информации. Значит под неё будет занят не только 132-й байт, а и 133, 134 и 135.
	Но мы то записали только 132 как адрес. А при разыменовании нужно достать 4 байта. Откуда программа будет знать, сколько байт ей достать при разыменовании?
	Ведь там только адрес 132.

	Вот тут вступает в ход базовый тип. Когда при определении указателя указано int * - это значит, что указатель "указывает на int".
	Значит при разыменовании будет взято 4 байта.
	Если будет в определении указано double * (указывает на double), то при разыменовании будет взято 8 байт.
*/

void main ()
{
	//Например:
	int val1 = 5; // Предположим, что val1 находится по адресу 100
	double val2 = 2.5; // Предположим, что val2 находится по адресу 200

	int *pVal1;
	double *pVal2;

	pVal1 = &val1; // Записываем в указатель pVal1 адрес переменной val1 (то есть 100, как мы предположили ранее)
	pVal2 = &val2; // Записываем в указатель pVal2 адрес переменной val2 (то есть 200, как мы предположили ранее)

	cout << *pVal1 << endl; // Поскольку pVal1 указывает на int, то при разыменовании он возьмет 4 байта по адресу 100
	// То есть байты по адресам: 100, 101, 102, 103

	cout << *pVal2 << endl; // Поскольку pVal1 указывает на double, то при разыменовании он возьмет 8 байт по адресу 200
	// То есть байты по адресам: 200, 201, 202, 203, 204, 205, 206, 207


	// Компилятор обеспечивает контроль типов. В том числе и контроль указательных типов.
	// Он не позволит неявно привести один указатель к другому, если базовый тип отличается.

	//pVal1 = &val2; // Нельзя в int * записать double *. 
	//pVal2 = pVal1; // Нельзя в double * записать int *

	// Но эти ограничения можно обойти, если Вы знаете, что делаете.
	pVal1 = (int *)pVal2; // Явно приводимся к int *. Явное приведение убирает претензии компилятора, и копируется адрес из указателя pVal2, в указатель pVal1.

	// Теперь и pVal1 и pVal2 указывают на одну и ту же область памяти:
	cout << "pVal1 = " << pVal1 << endl;
	cout << "pVal2 = " << pVal2 << endl;

	// Однако, что теперь будет при разыменовании pVal1? 
	// При разыменовании pVal2 всё будет чудесно, как и раньше. Ведь указываем на double. И по адресу тоже лежит double.
	// Взяли 8 байт по адресу и всё отлично.

	cout << "*pVal2 = " << *pVal2 << endl;

	// А вот при разыменовании pVal1 будет взято только 4 байта(!).  4 первых байта по адресу в указателе.
	// Это всё потому, что укзатель pVal1 объявлен как указатель на int (int *)
	cout << "*pVal1 = " << *pVal1 << endl;

	// Но тут в целом ошибки не будет, просто взяли не 8 байт из переменной, а только 4.
	// А что будет если сделать наоборот?

	pVal2 = (double *)&val1; // val1 это int. Занимает всего 4 байта, а мы её адрес (int *) преобразуем в double *
	//cout << "*pVal2 = " << *pVal2 << endl; // Берем 8 байт (т.к. double *), а там-то всего 4!!
	// Мы залезли на чужую область памяти. Это чревато серьезными ошибками. 

	// Мораль: Используйте явное приведение указателей только в том случае, когда понимаете что делаете и идете на это осознанно. 
	// Понимаете все риски и ошибки которые могут быть.
	// В остальных случаях компилятор неявные преобразования контролирует и минимизирует кол-во ошибок.
}