#include <iostream>
using namespace std;

/*
	В С/С++ массивы и указатели очень тесно связаны.
	Любую операцию по индексированию массива компилятор неявно выполняет через адресную арифметику.
	
	Читать ОБЯЗАТЕЛЬНО: http://www.cplusplus.com/doc/tutorial/pointers/
*/

void main ()
{
	int arr[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; // Создаем массив на 10 элементов
	
	// Что такое массив? Массив - это набор переменных одного типа, которые расположены в памяти последовательно.
	// Если каждый элемент массива это переменная, то у неё есть адрес, не так ли?
	// Давайте попробуем взять адрес 0-го элемента:
	cout << "&arr[0] = " << &arr[0] << endl; // Берем адрес 0 элемента массива (оператор [] более приоритетен, чем &, 
												// посему сначала выполнится индексация, а затем взятие адреса)

	cout << "&arr[1] = " << &arr[1] << endl; // А теперь берем адрес 1 элемента массива
	cout << "&arr[2] = " << &arr[2] << endl; // А теперь берем адрес 2 элемента массива

	// Посмотрите на вывод? На сколько отличаются адреса? На 4? А почему? Ведь размер одного элемента 4 байта, раз массив int.
	// И элементы расположены последовательно. Следовательно, следующий элемент будет в памяти через 4 байта после предыдущего.
	// А если бы массив был из элементов типа double, элементы были бы по 8 байт, и адреса отличались бы на 8.

	cout << "\n\n\n&arr[0] = " << &arr[0] << endl; // Давайте ещё раз выведем адрес 0 элемента
	cout << "arr = " << arr << endl; // А теперь попробуем сделать на первый взгляд глупость, и выведем не элемент массива, а обратимся к имени массива
	// ОПА! Вывелся адрес! Причем адрес 0 элемента!
	// Как же так? Всё очень просто - имя массива - это указатель на начало массива, т.е. на 0-й элемент. (смещение 0, помните?)
	
	// Указатели и массивы тесно связаны. На самом деле имя массива - это почти обычный указатель.
	// Только в имя массива нельзя присвоить какой-то левый адрес, и вообще ничего присваивать нельзя.
	// Он хранит адрес 0-го элемента массива. А для обращения по индексу (по смещению) применяется оператор индексирования.

	// Давайте поэкспериментируем. Если имя массива - это фактически указатель, то можно попытаться делать те вещи, которые делали с массивами
	// но на указателях! То есть, давайте сделаем обычный указатель на int. НО запишем туда адрес 0-го элемента массива. И попробуем применить индексирование!

	int *pArray = &arr[0]; // Копируем в указатель на int, адрес 0-го элемента массива
	// Можно сделать и так: int *pArray = arr; // Эффект тот же

	cout << "pArray[2] = " << pArray[2] << endl; // Смещаемся на 2 элемента относительно адреса в pArray
	// ВАУ! Работает! То есть, можно применять оператор индексирования и для указателей!
	// Коль имя массива это почти тот же указатель, то индексирование будет работать и для указателя.
	// Ведь происходит то же самое, мы берем элемент по смещению в скобках, относительно адреса 0-го элемента.
	cout << "arr[2] = " << arr[2] << endl;


	cout << "\n\nPointer arithmetic: \n\n";

	/*		Как это вообще работает?
				К указателям можно применять следующие операторы:
					1. Операторы сравнения, отношения (>, <, <=, >=, ==, !=) 
					2. Бинарные арифметические операторы:
						а. + (сложение), но только если второй операнд обычное целое число! (складывать два указателя нельзя!)
						б. - (вычитание), допускается второй операнд указатель на такой же тип или простое целое число
					3. Присваивание указателя такого же типа (=)
					4. Разумеется, специфические операторы для указателей: (&, *, [])
					5. sizeof
					6. Инкремент и декремент

			В языке С существует очень важный механизм - арифметика укзателей.
			Работа арифметических операторов с указателями немного отличается от обычной арифметики.
			Арифметика указателей корректно работает, если указатель указывает на память в массиве, в остальных случаях используйте, 
				если всецело понимаете что делаете. Некоторые оперторы не в пределах массива будут работать некорректно.
	*/

	// Возьмем например адрес 5-го элемента массива:
	cout << "&arr[5] = " << &arr[5] << endl;

	// То же самое применяя арифметику указателей:
	int *p = arr; // Берем адрес начала массива (0-го элемента)
	cout << "p = " << p << endl;
	cout << "p + 5 = " << p + 5 << endl;
	// Значения &arr[5] и p + 5 совпали не так ли?
	// Что делает оператор + для указателя? Мы указали + 5, значит ему необходимо высчитать адрес для смещения 5. 
	// Но смещения на 5 элементов! А сколько занимает один элемент? Массив int, значит каждый элемент занимает sizeof(int) байт, то бишь 4.
	// Значит нужно сместится на 5 * sizeof(int), то есть на 20 байт. Если Вы посчитаете, то заметите, что адрес 0-го элемента отличается от адреса 5-го на 20.

	// Оператор + (для укзателя) - работает только если один из операндов указатель, а другой целое число!
	// Прибавляет к адресу смещение на количество элементов базового типа.
	// Если некий указатель p указывает на адрес 100, то выполнив p + 10 МЫ НЕ ПОЛУЧИМ 110. 
	// Что мы получим зависит от базового типа p:
	//		Например: если p это int *, то p + 10 будет фактически равно 100 + 10 * sizeof(int), то есть результирующий адрес 140
	//				если p это double *, то p + 10 будет фактически равно 100 + 10 * sizeof(double), то есть результирующий адрес 180
	//				если p это short *, то p + 10 будет фактически равно 100 + 10 * sizeof(short), то есть результирующий адрес 120
	//				если p это char *, то p + 10 будет фактически равно 100 + 10 * sizeof(char), то есть результирующий адрес 110

	cout << endl << endl;

	// Давайте попробуем применить это на практике:
	cout << "arr[5] = " << arr[5] << endl; // Используем обычное индексирование для массива
	cout << "p[5] = " << p[5] << endl; // Используем обычное индексирование для указателя
	cout << "*(p+5) = " << *(p + 5) << endl; // Используем адресную арифметику
	// Скобки здесь необходимы, т.к. * более приоритетный оператор, чем +
	// Сначала мы высчитали смещение в массиве 5, получили адрес 5-го элемента, а затем разыменовали этот адрес и получили 5-й элемент массива


	cout << endl << endl;

	// p[5] и *(p + 5) - ЭКВИВАЛЕНТНЫ! Более того, компилятор на самом деле преобразует индексирование в арифметику указателей за кулисами.

	*(p + 5) = 12; // Изменяем 5-й элемент
	cout << "arr[5] = " << arr[5] << endl; // Смотрим, изменилось ли

	// Изменилось! 
	// Кроме того, поскольку имя массива это по сути указатель на 0-й элемент, то можно использовать арифметику указателей и вместо индексации для массивов
	cout << "*(arr+5) = " << *(arr + 5) << endl;

	// Компилятор преобразует оператор индексирования в арифметическое выражение с указателями:
		// arr[1] преобразуется в *(arr + 1)
		// arr[0] преобразуется в *(arr + 0)
		// arr[3] преобразуется в *(arr + 3)
		// arr[8] преобразуется в *(arr + 8)

	// А вот складывать два указателя нельзя!
	//cout << arr + p << endl; // Ошибка компиляции!

	// А давайте в p запишем адрес 4-го элемента массива:
	cout << endl << endl;


	p = arr + 4;
	cout << "*p = " << *p << endl;
	cout << "arr[4] = " << arr[4] << endl; // Совпало, не так ли? Вполне очевидно

	// Попробуем оператор -
	// Помните, что оператор "-" можно использовать с двумя указателями (одного типа), а вот "+" нельзя
	cout << "p - arr = " << p - arr << endl; // Что будет? 
	// p указывает на 4-й элемент массива, то есть на arr+4
	// мы отнимаем от этого arr
	// И вполне ожидаемо получаем 4!
	
	// Оператор "-" применимо к двум указателям возвращает разницу в количестве элементов между ними!
	// ВНИМАНИЕ! Это гарантировано корректно работает только, если адреса находятся в пределах массива, в остальных случаях корректная работа не гарантируется!
	// Будьте осторожны!


	// Операторы сравнения сравнивают два указателя. Если они находятся в пределах массива, то работа будет корректна, в противном случае
	//	корректность не гарантируется.
	cout << endl << endl;
	cout << "p > arr = " << (p > arr) << endl;
	cout << "p < arr = " << (p < arr) << endl;
	cout << "p >= arr = " << (p >= arr) << endl;
	cout << "p <= arr = " << (p <= arr) << endl;
	cout << "p == arr = " << (p == arr) << endl;
	cout << "p != arr = " << (p != arr) << endl;
	cout << "p == arr + 4 = " << (p == arr+4) << endl;



	// Например, вычисляя выражение p > arr мы можем узнать, указывает ли p на элемнент который дальше чем тот 
			//	на который указывает arr (то есть начало массива в данном случае)

	cout << endl << endl;

	cout << "*p = " << *p << endl; //Указывали на 4-й элемент
	cout << "*++p = " << *++p << endl; //Указываем на 5-й элемент

	// Приоритет декремента выше чем приоритет *, поэтому сначала выполнится декремент
	cout << "*p-- = " << *p-- << endl; //Всё ещё разыменовываем 5-й элемент, хотя p уже указывает на 4-й (постфиксный декремент)
	cout << "*p = " << *p << endl; // А теперь разыменовываем 4-й элемент
}