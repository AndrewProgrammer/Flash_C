#include <iostream>
using namespace std;

/*
	В языке С++ появился механизм перегрузки функций (function overload).
	Этот механизм позволяет объявить несколько функций с одним и тем же именем, но с разным списком параметров.
	
	У функции есть понятие сигнатуры.
	Сигнатура функции - это набор характеристик, которые позволяют однозначно отличить эту функцию от других.
	В сигнатуру входит имя функции и список параметров (кол-во параметров, типы параметров и порядок).
	ВНИМАНИЕ! В сигнатуру не входит тип возвращаемого значения. Перегрузить функции, которые отличаются только возвр. значением нельзя!

	Механизм перегрузки позволяет определить несколько функций, которые имеют разную сигнатуру, но один и тот же идентификатор (имя).
	Это необходимо для написания функций, у которых одна и та же задача, но необходимо разное количество или типы аргументов.

	ВАЖНО! Компилятор должен ОДНОЗНАЧНО определить какую из функций вызвать. Если он этого сделать не может - возникает
	ошибка компиляции "Неоднозначный вызов" (ambigous call).

	Которая из функций будет вызвана, определяется компилятором исходя из фактических аргументов: их количества, порядка и типов.
	Процедура, при которой компилятор определяет для какой конкретно функции (из списка перегрузки) генерировать код для вызова
		называется - разрешение перегрузки. (overload resolution)

	Эта процедура подчиняется ряду правил - правилам разрешения перегрузки.
	
	Вначале определяется набор т.н. подходящих функций (viable functions) по кол-ву аргументов.
	Например, если вызывается функция и ей передается при вызове 2 аргумента, то из списка будут выбраны все функции,
		которые можно вызвать, передав 2 аргумента (функции, принимающие ровно 2 аргумента, или имеющие помимо 2-х обязательных аргументов 
		аргументы по умолчанию). При этом не учитываются типы аргументов. Только их количество.

	Если подходящих функций нет - ошибка компиляции.
	Если подходящая функция одна - разрешение перегрузки завершено, генерируется код для вызова.
	Если подходящих функций несколько - выбирается наилучший вариант (best match) (см. ниже).

	После того, как список подходящих по кол-ву аргументов функций будет сформирован - применяется специальная система,
		которая выбирает НАИБОЛЕЕ подходящую функцию.

	Здесь используется простая система рейтинга (от наилучшего варианта, к наихудшему)
	
	1. Полное совпадение. (Типы аргументов полностью совпадают, например если формальный параметр double - то и фактический тоже double).
		Полное совпадение работает когда никаких преобразований выполнять не нужно. 
		При этом квалификатор const не играет никакой роли при разрешении перегрузки.

	2. Необходимо продвижение (один из видов преобразований, не требующий сложных действий) (numeric promotions):
		Например, если существует 2 функции:
			void print(float);
			void print(int);
		При попытке вызова print('a') возникнет проблема - какую функцию вызвать? 
		Полного совпадения нет, однако преобразование от char к int - это довольно тривиальная задача, которая относится к продвижениям (promotions),
			соответственно компилятор выберет функцию с формальным параметром int, хотя фактический аргумент при вызове был char. 

		Это происходит из-за того, что у продвижений ранг выше (ранг 2), чем у преобразований (ранг 3). Соответственно продвижениям отдается предпочтение.

		К продвижениям относят:
			а. signed char и signed short - может быть "продвинуто" к int
			b. unsigned char и unsigned short - может быть "продвинуто" к int, если в int влезет диапазон, иначе к unsigned int
			c. Константы перечисления (enum) могут быть "продвинуты" к следующим типам (конкретный тип определяется по диапазону значений -
					минимальный, в который влезут все значения перечисления) - int, unsigned int, long, unsigned long, long long, unsigned long long
			d. bool - может быть "продвинуто" к int
			e. float - может быть "продвинуто" к double
		
		Все остальные преобразования НЕ ОТНОСЯТСЯ к продвижениям!

	3. Преобразования типов
		a. Преобразования целых типов (кроме char, short к int - это продвижение)
		b. Преобразования дробных типов (кроме float к double - это продвижение, а double к float - уже не продвижение, а преобразование)
		c. Преобразование между целыми и дробными типами
		и  прочие преобразования


	Компилятор определяет типы формальных аргументов, фактических аргументов и определяет наилучшее совпадение исходя из ранга.
	Точное совпадение предпочтительнее, чем продвижение. Если точного совпадения нет, а есть продвижение - компилятор выберет провдижение.
	Если нет продвижения, но есть возможность преобразования - будет выбрано преобразование.
	Если нет и возможности преобразования - будет ошибка компиляции (этот случай будет рассмотрен позже в теме "Структуры")

	Существует проблема неоднозначности. Когда невозможно определить наилучший вариант и ранги нескольких функций совпадают.
	Когда компилятор встречается с этой проблемой - генерируется ошибка компиляции.

	Например: есть 2 подходящих функции. Необходимо определить наилучший вариант.
	Точных совпадений нет, продвижений нет, но есть вариант преобразований. И в первом случае надо делать преобразования, и во втором случае
		также необходимо делать преобразования. С точки зрения компилятора они равноправны, соответственно лучшего варианта нет.
		Ошибка компиляции - неоднозначный вызов (ambigous call).

*/



double Average (double, double);
double Average (double, double, double = 10); // При попытке вызова функции с 2 аргументами
													// возникнет ошибка компиляции из-за неоднозначности

void Square (int);
void Square (double);
void Square (long);


void main ()
{
	
	cout << "Average(2.2, 3.3, 4.4): " << Average (2.2, 3.3, 4.4) << endl;
	//cout << "Average(2.2, 3.3): " << Average (2.2, 3.3) << endl; // Ошибка ambigous call - две функции подходят для вызова


	Square (10);	 // Square(int) - точное совпадение типов
	Square (10.);	 // Square(double) - точное совпадение типов
	Square (10L);	 // Square(long) - точное совпадение типов
	Square (10.f);	 // Square(double) - продвижение от float к double
	Square ('a');	 // Square(int) - продвижение от char к int
	

	short sValue = 15;
	Square (sValue); // Square(int) - продвижение от short к int

	long long llValue = 20;
	//Square (llValue); // Error! Неоднозначный вызов. Функции с таким аргументом нет, продвижения тоже нет, значит необходимо преобразовывать.
						// А для преобразования есть несколько вариантов.

	//Square (20U); // Error! Аналогично вышенаписанному.
}


double Average (double first, double second)
{
	return (first + second) / 2;
}


double Average (double first, double second, double third)
{
	return (first + second + third) / 3;
}

void Square (int num)
{
	cout << "Square(int): " << num * num << endl;
}

void Square (double num)
{
	cout << "Square(double): " << num * num << endl;
}

void Square (long num)
{
	cout << "Square(long): " << num * num << endl;
}